generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -- Events --
model Event {
  id          String   @id @default(cuid())
  title       String
  description String?
  image       String?  // Main banner
  startDate   DateTime
  endDate     DateTime
  location    String   @default("TKOB Main Hall")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  priceAreas  PriceArea[]
  bookings    Booking[]
}

// -- Pricing Rules --
// Each event has multiple PriceAreas.
// Highest priority match wins for a seat.
model PriceArea {
  id          String   @id @default(cuid())
  eventId     String
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  name        String   // e.g. "Plate Rows 1-5"
  
  // Selectors: How we target seats. 
  // Stored as JSON: { rows: ["A","B"], blocks: ["Llozha 1"], seatNumbers: [1,2,3] }
  // If a seat matches ANY of the conditions (OR logic inside, AND logic between fields? Usually simple inclusion)
  // Let's define it as strict JSON for flexibility.
  selectors   String   // JSON string
  
  saleStatus  String   // FOR_SALE, NOT_FOR_SALE, ADMIN_RESERVED
  price       Float?   // NULL if not for sale
  priority    Int      @default(0) // Higher wins
  
  color       String?  // For admin visualization (hex)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// -- Seats (Static Layout) --
model Seat {
  id          String   @id @default(cuid())
  section     String   // "Parterre", "Llozha 1", "Llozha 2"
  row         String?  // "A", "B", ...
  number      String   // "1", "2", ...
  x           Float?   // Coordinate for canvas
  y           Float?   // Coordinate for canvas
  
  // No relation to EventPrice, computed at runtime
  bookings    Ticket[]
}

// -- Bookings & Users --
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String?
  password    String?  // Null for guest
  role        String   @default("USER") // ADMIN, USER
  
  bookings    Booking[]
  createdAt   DateTime @default(now())
}

model Booking {
  id            String   @id @default(cuid())
  userId        String?
  user          User?    @relation(fields: [userId], references: [id])
  
  guestEmail    String?  // Redundant but useful if user not linked
  guestName     String?

  eventId       String
  event         Event    @relation(fields: [eventId], references: [id])
  
  status        String   // PENDING, CONFIRMED, CANCELLED, EXPIRED
  totalAmount   Float
  currency      String   @default("ALL")
  
  expiresAt     DateTime? // For hold
  paymentIntent String?  // Stripe ID
  
  tickets       Ticket[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Ticket {
  id          String   @id @default(cuid())
  bookingId   String
  booking     Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  seatId      String
  seat        Seat     @relation(fields: [seatId], references: [id])
  
  priceAtBooking Float
  
  @@unique([bookingId, seatId]) // One ticket per seat per booking
}

// -- CMS Content --
model PageContent {
  key       String   @id // e.g. "about.en", "about.sq"
  content   Json     // Structure depends on page
  updatedAt DateTime @updatedAt
}

// Payment system enums
enum OrderStatus {
  PENDING
  PAID
  FAILED
  EXPIRED
}

enum SeatLockStatus {
  HELD
  SOLD
  RELEASED
}

// Order model for guest checkout
model Order {
  id              String      @id @default(cuid())
  eventId         String
  email           String
  fullName        String
  phone           String?
  currency        String      @default("ALL")
  totalAmountALL  Int
  status          OrderStatus @default(PENDING)
  paymentProvider String      @default("2checkout")
  paymentRef      String?
  publicToken     String      @unique // For guest access to order
  
  // Timestamps
  createdAt       DateTime    @default(now())
  paidAt          DateTime?
  
  // Email tracking
  emailSentAt     DateTime?
  lastEmailError  String?
  
  // File URLs
  ticketUrl       String?
  invoiceUrl      String?
  icsUrl          String?
  
  // Relations
  items           OrderItem[]
  locks           SeatLock[]
  
  @@index([email])
  @@index([status])
  @@index([publicToken])
}

model OrderItem {
  id         String @id @default(cuid())
  orderId    String
  seatId     String
  seatLabel  String
  priceALL   Int
  
  order      Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId])
}

model SeatLock {
  id        String          @id @default(cuid())
  eventId   String
  seatId    String
  orderId   String
  expiresAt DateTime
  status    SeatLockStatus  @default(HELD)
  
  order     Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  // Prevent double booking
  @@unique([eventId, seatId])
  @@index([eventId, expiresAt])
  @@index([orderId])
}
